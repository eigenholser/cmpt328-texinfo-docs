\input texinfo   @c -*-texinfo-*-

@set title Lab 3: Interrupts
@set subtitle CMPT 328 Computer Architecture
@set splash1 lab_3_interrupts-splash.texi
@set splash2 westminster-splash.texi
@set author Scott Overholser
@set category Laboratory
@set filename lab_3_interrupts

@c lab constants
@set main_reg 72
@set main_loop_bp 77
@set gpiof_entry 242
@set gpiof_bx 247
@set systick_bp 263

@comment %**start of header
@setchapternewpage off
@setfilename @value{filename}.info
@settitle @value{title}
@finalout
@comment %**end of header

@include @value{filename}.texi.updated
@include copying.texi

@titlepage
@title @value{title}
@subtitle @value{subtitle}
@include @value{splash1}
@author @value{author}

@c Secondary title page.
@page
@include @value{splash2}
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@comment Table of Contents
@contents

@dircategory @value{category}
@direntry
* Texinfo Doc Template         Template for Creating New Docs
@end direntry

@include headings.texi
@include constants.texi

@ifnottex
@node Top
@top @value{title}

@insertcopying
@end ifnottex

@comment This is the Chapter Menu
@menu
* Introduction::            Introduction
* Lab Objective::           Lab Objective
* Notes::                   Notes
* Experiments::             Experiments
* Lab Report::              Lab Report
@end menu

@comment This is a starting point.
@node Introduction
@chapter Introduction
@noindent
In Lab 2 we learned about fault conditions, the resulting processor exceptions,
and how to handle them. Interrupts are similar in that program execution is
abruptly changed and the location of the Interrupt Service Routine (ISR), like
the fault handler, is specified in the @emph{vector table}. The difference is
that interrupts are more configurable to suit our purposes.

@noindent
For Lab 3 we will examine an assembly language program that uses two different
interrupts. An edge-triggered interrupt is configured for GPIO port F switch
SW1. Another interrupt is configured for the SysTick timer that is used in
debouncing the switch.

@noindent
Lab 3 also introduces the @file{startup.s} file that provides a complete
@emph{vector table} for our program. This file will be used with only minor
modifications in all future assembly projects. You can consider it largely
@emph{boilerplate} code.

@noindent
This lab also introduces a fully functional example of how to
work with the GPIO ports. We will be working with GPIO port F. Even though
each GPIO port offers different features and has it's own configuration, they
are all very similar in terms of usage. The LaunchPad has 6 GPIO ports, A-F.

@noindent
The program we will be working with in this lab activates one of the three
LEDs when switch SW1 is pushed. Each push of the switch is handled by the two
different ISRs which together cooperate to process the switch SW1 interrupt
and rotate the active LED.

@noindent
The switch SW1 is a mechanical switch and is imperfect---it bounces one or
more times when pressed. These bounces are very short on the 1ms time scale.
So humans do not notice this. We experience a crisp click as we press the
button. But the processor at a clock speed of 80MHz cycles about one hundred
thousand times each millisecond and notices each bounce and acts on it. The
result is multiple LED rotations for each press of switch SW1.

@noindent
The solution to this problem is to implement a debouncing algorithm. I chose
the SysTick timer to implement debouncing. The basic idea is to have the GPIO
port F ISR turn off interrupts on GPIO port F and initialize the SysTick timer
with interrupts. The SysTick interrupt handler is activated and checks the
switch SW1 value. If it is logic LOW, then the switch SW1 is pressed and the
LED colors are rotated. If switch SW1 value is logic HIGH, then re-arm the
GPIO port F interrupt and carry on as before. In either case, the SysTick ISR
disables the SysTick timer because we need it only once per SW1 activation.

@noindent
Note the many places in the code where register LR is pushed onto the stack
prior to branching. This saves the LR value so the code can return from a
previous branch using @code{BX LR}.

@node Lab Objective
@chapter Lab Objective
@noindent
This lab will explore interrupts, what they are, and how to use them.
Interrupts are an important part of modern processor architecture. Secondarily,
you will learn how to use the General Purpose Input/Output (GPIO) system.

@noindent
The project you will be working with is much larger than previous lab projects.
Don't let that bother you---the objective is to learn about interrupts and the
GPIO system.

@noindent
You will be introduced to the LaunchPad schematic in the
@uref{https://westminster.instructure.com/files/62246648/download?download_frd=1&verifier=4ckiiqMaZjgvEiJdL2KBeiKBlUvQgrtvoq1e4lkF, TM4C123G LaunchPad Evaluation Board Users Guide.}
This will help you understand how to use the GPIO.
You will continue learning how to use the
@uref{https://westminster.instructure.com/files/62246649/download?download_frd=1&verifier=hkiu21FqwDA10ZbhaXkJGY4SDvWC55QpRD9xEpo7, Tiva TM4C123GH6PM Microcontroller Data Sheet}
as a reference.

@node Notes
@chapter Notes
@noindent
You should now be familiar with your IAR Embedded Workbench development
environment. You should also be understanding the @emph{boot loading} process
and the purpose of the @emph{vector table}. You should also be comfortable
referencing the TM4C datasheet.

@section Reference Material
@noindent
@uref{https://westminster.instructure.com/files/62246649/download?download_frd=1&verifier=hkiu21FqwDA10ZbhaXkJGY4SDvWC55QpRD9xEpo7, Tiva TM4C123GH6PM Microcontroller Data Sheet}
will be referenced often in this and future labs. It is in the Canvas Files
area filed under Tiva C Series Microcontroller. The filename is
@file{tm4c123gh6pm.pdf}.

@noindent
This lab exercise introduces the
@uref{https://westminster.instructure.com/files/62246648/download?download_frd=1&verifier=4ckiiqMaZjgvEiJdL2KBeiKBlUvQgrtvoq1e4lkF, TM4C123G LaunchPad Evaluation Board Users Guide.}
It is in the Canvas Files area in the Tiva C Series Microcontroller folder. The
filename is @file{spmu296.pdf}. Download this file to your computer.

@noindent
The User's Guide  is useful primarily for the schematics following page 19.
The schematics offer information about the configuration of the GPIO
pins, switches, LEDs, and jumper blocks. You will need to reference the
schematic for this and future labs.

@noindent
Also refer to @file{lm4f120h5qr.h} in the @file{arm/inc/TexasInstruments}
folder on your development system. This is a C header file that contains
useful C macro definitions for the TM4C.

@itemize
@item @cite{Figure 1-1. Tivaâ„¢ TM4C123GH6PM Microcontroller High-Level Block Diagram}---datasheet, p48.
@item @cite{2.3.2 Stacks}---datasheet, p74.
@item @cite{2.5.4 Vector Table}---datasheet, p106.
@item @cite{2.5.7.1 Exception Entry}---datasheet, p109.
@item @cite{2.5.7.2 Exception Return}---datasheet, p110.
@item @cite{Figure 2-7. Exception Stack Frame}---datasheet, p110.
@item @cite{Register 1: SysTick Control and Status Register (STCTRL), offset 0x010}---datasheet, p138.
@item @cite{Register 2: SysTick Reload Value Register (STRELOAD), offset 0x014}---datasheet, p140.
@item @cite{Register 3: SysTick Current Value Register (STCURRENT), offset 0x018}---datasheet, p141.
@item @cite{Register 4: Interrupt 0-31 Set Enable (EN0), offset 0x100}---datasheet, p142.
@item @cite{Register 32: Interrupt 12-15 Priority (PRI3), offset 0x40C}---datasheet, p152.
@item @cite{Register 36: Interrupt 28-31 Priority (PRI7), offset 0x41C}---datasheet, p152.
@item @cite{Register 9: GPIO High-Performance Bus Control (GPIOHBCTL), offset 0x06C}---datasheet, p258.
@item @cite{Register 60: General-Purpose Input/Output Run Mode Clock Gating Control (RCGCGPIO), offset 0x608}---datasheet, p340.
@item @cite{10.4 Register Map}---datasheet, p658.
@item @cite{Table 10-6. GPIO Register Map}---datasheet, p660.
@item @cite{Register 2: GPIO Direction (GPIODIR), offset 0x400}---datasheet, p663.
@item @cite{Register 6: GPIO Interrupt Mask (GPIOIM), offset 0x410}---datasheet, p667.
@item @cite{Register 9: GPIO Interrupt Clear (GPIOICR), offset 0x41C}---datasheet, p670.
@item @cite{Register 15: GPIO Pull-Up Select (GPIOPUR), offset 0x510}---datasheet, p677.
@item @cite{Register 18: GPIO Digital Enable (GPIODEN), offset 0x51C}---datasheet, p682
@end itemize

@node Experiments
@chapter Experiments
@noindent
Download and extract the Lab 3 project zip file. Double-click on
@file{workspace.eww} to start IAR Embedded Workbench.

@noindent
Review the code. Look at @file{startup.s}. The complete @emph{vector table} is
implemented there. The only exceptions are @code{GPIOPortF_Handler} and
@code{SysTick_Handler}. They are included in @file{main.s}.

@noindent
All of the logic for this project is implemented in @file{main.s}. The @code{main}
function simply initializes GPIO Port F and GPIO Port F pin 4 (SW1) interrupts.
Incidentally, it also loads some junk data into registers @code{R0}, @code{R1},
@code{R2}, @code{R3}, and @code{R12} to make the @emph{stack frame} easier to
see. But this step is for purposes of illustration only. It does not contribute
to program function at all.

@noindent
After initialization, the @code{main} function just loops forever. This is
just to simulate other activity that the processor might be doing as interrupts
occur. The other activity might be reading from a UART, an ethernet port, or
reading keyboard input.

@section Start Program in Debugger
@noindent
Compile the program. Then Download and Debug. The debugger will break at @code{main}
as usual. Click the "Go" button in the debug toolbar. It is the button with "+++"
on it. The program will begin executing. Confirm program operation by pressing
the button labeled SW1 on your LaunchPad board.

@section GPIO Port F Interrupt Handler
Stop debugging.
In the @file{main.s} source view, set breakpoints @code{main} at line
@value{main_reg}, and in @code{GPIOPortF_Handler}
at line @value{gpiof_entry} and @value{gpiof_bx},

@noindent
Download and Debug. Click the "Go" button once again. The program will stop
at the first breakpoint on line @value{main_loop_bp}. Single-step (click the
"Step Into" button on the debug toolbar) through the @code{LDR} instructions
that load the @emph{junk} values into the registers. @emph{Note the register
values as you do this.} You will see each update in turn. Stop single stepping
when you reach the @code{B .} infinite loop.

@noindent
Click the "Go" button in the debug toolbar. The program will run freely.
Then push the button SW1 on the LaunchPad board. The program will stop
at the breakpoint set on line @value{gpiof_bx}. The GPIO Port F SW1 interrupt
was triggered by the button push.

@noindent
@emph{Note the value of the SP register.} In the memory view click in the
"Go to" field and enter the SP register value using the @code{0x} hexadecimal
notation. Compare the 4-byte words on the stack with the register values noted
above. Review @emph{Figure 2-7. Exception Stack Frame} on page 110 of the
datasheet. @emph{Note the contents of the general purpose registers R0-R3, R12.}
They are the same as before. Even though they have been pushed onto the stack,
their values are unchanged.

@noindent
@emph{Note the value of register IPSR.}

@noindent
At this point, note that @code{GPIOPortF_Handler} performs only three tasks:
It clears the interrupt. If this is not done, the interrupt will assert over
and over. Then it disables the SW1 interrupt. Finally it initializes the
SysTick timer with interrupt. Program execution then resumes in the @code{main}
infinite loop. Click the "Go" button in the debug toolbar.

@noindent
Program execution will stop at the breakpoint set on line @value{gpiof_bx}.
@c Now set another breakpoint in @code{main} at line @value{main_loop_bp}. We
@c could not do this before because the program will not loop at a breakpoint
@c and we cannot trigger an interrupt while program execution is stopped.
@emph{Note the contents of the general purpose registers.} They have changed
because they are modified by the @code{GPIOF_PF4_Interrupt_Clear},
@code{GPIOF_PF4_Interrupt_Disable}, and @code{SysTick_Init} functions.

@noindent
Click the "Step Into" button on the debug toolbar. Program execution will now
be stopped at the @code{B .} infinite loop instruction in @code{main}. @emph{
Note both the general purpose and special purpose registers.} They now contain
their original values once again. @emph{Note the memory view at the top of the
stack. The stack frame has not been erased, only copied back to the registers.}

@noindent
You are ready to proceed with the next section.

@section  SysTick Interrupt Handler
The SysTick timer will
interrupt almost immediately as we click the "Go" button on the debug toolbar. Before
we do that, in the @file{main.s} source view set a breakpoint in
@code{SysTick_Handler} at line @value{systick_bp}. Now click the "Go" button.

@noindent
Program execution will be broken at line @value{systick_bp} in the
@code{SysTick_Handler}. Note that the first action taken by the @code{SysTick_Handler}
is to disable the SysTick timer. We are done with with the timer. It is only
for a SW1 debounce.

@noindent
@emph{Note again the SP register.} The @emph{stack frame} has again been pushed
onto the stack. Since it is the same as before it will appear unchanged.
@emph{Note the value of register IPSR.}

@noindent
This is where the real action occurs. The first step is to check the value of
SW1. If it is still pressed, then it is a real button push. Keep in mind that
at full speed, only a few milliseconds have elapsed since you pushed the button.
But, the stray bounces have been avoided.

@noindent
The second action will depend on whether SW1 is logic LOW or logic HIGH. See?
Binary. If SW1 is logic LOW, it is a button push and the LED bit will be shifted
into the next position. If SW1 is logic HIGH, the LED bit rotation will be
skipped. In both cases the GPIO port F SW1 interrupt will be re-enabled

@noindent
Since we did push the button, single-step through the code and follow what
happens. On the @emph{View} menu select @emph{Watch->Watch 1.} Arrange the
Watch window conveniently. In the @emph{Expression} field enter "R1". In the
@emph{Value} field, right-click on the value and select "Binary Format."
Make the field wide enough to view all 32 binary digits in the @emph{Value}
field. @emph{Since you downloaded this project you should already see the
Watch window. The instructions are for completeness only.}

@noindent
The first time through register R1 will be zero. Step through the code anyway
to see how it is initialized with the green bit which is @code{0x8}. At this
point you should see a single bit set in register R1 corresponding to @code{0x8}.

@noindent
Clear all breakpoints except the one in @code{SysTick_Handler} at line
@value{systick_bp}. Click the "Go" button on the debug toolbar. Now each time
you press SW1 program execution will break in @code{SysTick_Handler}.

@noindent
Press the SW1 button repeatedly. Each time program execution breaks in
@code{SysTick_Handler}, single-step through the code. Make note of the @emph{Watch}
window and the binary value of register R1. Watch when the @code{LSRS} instruction
is executed. This instruction is Logical Shift Right. Bit position 0 is for
SW2. After the red LED is set, the bit will be shifted into the SW2 position.
But we do not have any interest in SW2 and we do have an interest in testing
for end of rotation. So on each bit shift,  a @code{BIC} or bit clear
instruction is used to clear bit position 0. Then if register R1 is nonzero,
@code{CBNZ} Compare Branch Non Zero is done to @code{SetLED} to set the
shifted bit value. Otherwise, register R1 is zero and is reinitialized with
@code{0x8}.

@comment read-modify-write issues

@section GPIO Port F Initialization
@noindent
Review page 1 of the LaunchPad schematics in the LaunchPad User's Guide. The
physical GPIO pins are presented in detail there. In the upper left is a
partial representation of chip U1 labeled U1-A. Each GPIO pin is labeled
with it's port designator and a pin number. For example, USR SW1 is labeled
PF4 to indicate Port F pin 4. Similarly, the LEDs are labeled PF1, PF2, and
PF3.

@noindent
Note also the representation of SW1 in the middle of page 1 of the schematic.
It shows a switch that will short to GND when pressed. In the lower left on
the same page see LED_R, LED_G, and LED_B.

@noindent
Review the High-Level Block Diagram listed in the References section. It is on
page 48 of the datasheet. Note that there are two busses used for communicating
with the peripherals. The Advanced Peripheral Bus (APB) is the legacy bus and is
used for compatability. It is the default. We will be using the faster
Advanced High Performance Bus (AHB).

@noindent
Turn your attention now to the code in the IAR Embedded Workbench. See the
function @code{GPIOF_Init}. This section of code initializes GPIO port F and
the specific GPIO port F pins we want to use. This is done very simply by
writing to various control registers.

@noindent
@code{GPIOF_Init} takes 4 steps:
@itemize
@item Select the AHB.
@item Enable GPIO port F clock.
@item Set the direction of the LED pins to output. The default direction is
input.
@item Set PF1-4 as digital.
@end itemize

@noindent
Note how the register values are set. First, the register address is loaded into
register R0. Then the value of the register is loaded into register R1. Then
the @code{ORR} instruction is used to toggle only 1 bit. Recall from the
Boolean Null Element theorem (T2') @code{B + 1 = 1} that any binary digit OR
1 is equal to 1. The resulting value is stored back into the register at the
address in register R0.

@noindent
This is an important approach. Using the @code{ORR} instruction does not
disturb any other bits in the register that are already set and we do not need
to test them individually. Nor do we stomp on them by using
@code{LDR R1, 0x20} that would set bit 5 but would also @emph{clear} every
other bit!

@noindent
Single-step through @code{GPIOF_Init} to familiarize yourself with it's
operation.

@section GPIO Port F Interrupt Initialization
@noindent
The code in @code{GPIOF_Interrupt_Init} configures the interrupt on SW1.
GPIO interrupts must be configured in two steps. First, configure the Nested
Vector Interrupt Controller (NVIC) to process the interrupt. Second, configure
the GPIO interrupt.

@noindent
Configuring the NVIC is easy. Just set the priority of the specific interrupt
that you want to handle. In our case we are selecting the highest priority of
0. Next, set the enable bit in the memory mapped register NVIC_EN0.

@noindent
Configuring the interrupt on SW1 is also easy. Edge-triggered interrupts are
the default selection and that is what we want to nothing needs to be done for
that. But we do need to select pull up on PF4 so the logic level is HIGH by
default. Recall from the schematic that a SW1 press connects PF4 to GND. If
we did not pull PF4 HIGH, there would be no logic level change on SW1 press.
Last, we need to set the GPIO port F interrupt mask to select interrupts on
PF4.

@noindent
Now interrupts are fully configured in the NVIC and GPIO port F. Single-step
through @code{GPIOF_Interrupt_Init} to familiarize yourself with it's operation.

@section SysTick Timer Initialization
@noindent
The SysTick timer implements a simple countdown timer. The 24-bit countdown or
RELOAD value is loaded into the NVIC_ST_RELOAD register. Once enabled, the
SysTick timer counts down from this value once per clock cycle. The current
value of the timer is stored in NVIC_ST_CURRENT. When the count down reaches
zero, time is up. In our case, we setup an interrupt to be triggered when the
count down reaches zero.

@noindent
The SysTick timer is useful because we do not need to implement it in our code.
It is an automatic mechanism of the processor. If we want to implement a delay
loop, we can just loop and wait until the NVIC_ST_CURRENT value reaches zero.
Or, we can setup the interrupt and forget about it until the interrupt is
triggered. The latter is the approach taken in this project.

@noindent
Configuring the NVIC is the same as described earlier in GPIO Port F Interrupt
Initialization. To configure the SysTick timer, we need to first disable the
timer so it is not counting down as we are configuring it. Then the countdown
value is loaded into the NVIC_ST_RELOAD register. The NVIC_ST_CURRENT register
is cleared. Once fully configured, we enable the SysTick timer with interrupts.

@noindent
In the source view clear all breakpoints. Set a breakpoint in @file{main.s} at
line 187. Click the "Go" button on the debug toolbar. Press button SW1 on the
LaunchPad. Program execution will stop at your breakpoint. Single-step through
the @code{SysTick_Init} code to familiarize yourself with it's operation.

@node Lab Report
@chapter Lab Report
@noindent
Lab report will focus on the general purpose of interrupts as well as their
specific use in this lab project. It will also cover the roles played by the
vector table and the stack. Observations made during the experiments chapter
will be integrated with the report.

@bye
